"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseStatusTracker = exports.AsyncTimeout = void 0;
exports.raceToResolution = raceToResolution;
exports.defer = defer;
exports.delay = delay;
exports.wrapWithTimeout = wrapWithTimeout;
const Exceptions_1 = require("../Exceptions");
const node_timers_1 = require("node:timers");
async function raceToResolution(promises, onErrorCallback) {
    const indexPromises = promises.map((p, index) => p.catch(() => {
        throw index;
    }));
    try {
        return await Promise.race(indexPromises);
    }
    catch (index) {
        const p = promises.splice(index, 1)[0];
        p.catch(err => {
            if (onErrorCallback) {
                onErrorCallback(err);
            }
        });
        return raceToResolution(promises);
    }
}
function defer() {
    let resolve;
    let reject;
    let isFulfilled = false;
    const promise = new Promise(function (res, rej) {
        resolve = v => {
            isFulfilled = true;
            res(v);
        };
        reject = rej;
    });
    return {
        resolve,
        reject,
        promise,
        isFulfilled
    };
}
async function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
async function wrapWithTimeout(promise, ms) {
    let timeoutHandle;
    const error = (0, Exceptions_1.getError)("TimeoutException", `Timeout after ${ms} ms.`);
    const timeoutPromise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => {
            resolve(error);
        }, ms);
    });
    try {
        const raceWinner = await Promise.race([promise, timeoutPromise]);
        if (raceWinner === error) {
            throw raceWinner;
        }
        else {
            (0, node_timers_1.clearTimeout)(timeoutHandle);
            return raceWinner;
        }
    }
    catch (e) {
        (0, node_timers_1.clearTimeout)(timeoutHandle);
        throw e;
    }
}
class AsyncTimeout {
    get promise() {
        return this._promise;
    }
    get timedOut() {
        return this._timedOut;
    }
    constructor(ms, op) {
        this._timedOut = false;
        this._op = op;
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
        this._timer = setTimeout(() => {
            this._timedOut = true;
            this._reject(this._getTimeoutError(ms));
        }, ms);
    }
    _getTimeoutError(ms) {
        const opText = this._op ? `Operation '${this._op}'` : `Operation`;
        const timeoutError = (0, Exceptions_1.getError)("TimeoutError", `${opText} timed out after ${ms} ms.`);
        return timeoutError;
    }
    cancel() {
        if (this._timer) {
            (0, node_timers_1.clearTimeout)(this._timer);
        }
        this._resolve();
    }
}
exports.AsyncTimeout = AsyncTimeout;
class PromiseStatusTracker {
    constructor(promise) {
        if (!promise) {
            throw new Error("Promise to track cannot be null.");
        }
        this._status = "PENDING";
        this._promise = promise;
        this._promise
            .then(() => this._status = "RESOLVED")
            .catch(() => this._status = "REJECTED");
    }
    static track(promise) {
        return new PromiseStatusTracker(promise);
    }
    isFullfilled() {
        return this._status === "REJECTED" || this._status === "RESOLVED";
    }
    isResolved() {
        return this._status === "RESOLVED";
    }
    isRejected() {
        return this._status === "REJECTED";
    }
}
exports.PromiseStatusTracker = PromiseStatusTracker;
//# sourceMappingURL=PromiseUtil.js.map